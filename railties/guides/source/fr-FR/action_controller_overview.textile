h2. Présentation d'Action Controller

Dans ce guide vous allez apprendre comment les contrôleurs fonctionnent et comment ils s'intègrent au cycle des requêtes de votre application. Après avoir lu ce guide, vous serez capable de:

* Suivre le déroulement d'une requête à travers un contrôleur
* Comprendre pourquoi et comment enregistrer des données dans une session ou des cookies
* Travailler avec des filtres pour exécuter du code pendant le traitement d'une requête
* Utiliser l'authentification HTTP intégrée d'Action Controller
* Envoyer des données directement au navigateur de l'utilisateur
* Filtrer les données sensibles pour qu'elles n'apparaissent pas dans les logs de l'application
* Traiter les exceptions qui pourraient apparaitre durant le traitement d'une requête

endprologue.

h3. Que fait un Contrôleur ?

Action Controller est le C de MVC. Après que le routage ait déterminé quel contrôleur utiliser pour une requête, votre contrôleur à la charge de donner un sens à votre requête et de produire la sortie appropriée. Heureusement, Action Controller fait la majeure partie de la préparation pour vous et utilises des conventions intelligentes pour rendre ceci le plus simple possible.

Dans la plupart des applications RESTful, le contrôleur va recevoir la requête (c'est invisible pour vous, le développeur), récupérer ou sauver des données depuis un modèle et utiliser une vue pour créer un fichier HTML. Si votre contrôleur doit faire les choses légèrement différemment, ce n'est pas un problème, c'est juste la façon la plus commune pour un contrôleur de fonctionner.

Un contrôleur peut donc être imaginé comme un intermédiaire entre les modèles et les vues. Il rends disponibles aux vues les données des modèles pour que celles-ci puissent les afficher à l'utilisateur, et il sauvegarde ou mets à jour les données de l'utilisateur vers le modèle.

NOTE: Pour plus de détails sur le traitement du routage, see "Rails Routing from the Outside In":routing.html.

h3. Méthodes et Actions

Un controlleur est une classe Ruby qui hérite de +ApplicationController+ et a des méthodes comme n'importe quelle autre classe. Lorsque votre application recoit une requete, le routage détermine quel controlleur et action utiliser, puis Rails crée une instance de ce controlleur et exécute une méthode du même nom que l'action.

<ruby>
class ClientsController < ApplicationController
  def new
  end
end
</ruby>

Par exemple, si un utilisateur va sur +/clients/new+ dans votre application pour ajouter un nouveau client, Rails va créer une instance de +ClientsController+ et exécuter la méthode +new+. Notez que la méthode vide de l'exemple ci-dessus fonctionnerait car Rails affichera par défaut la vue +new.html.erb+ à moins que l'action soit définie différemment. La méthode +new+ pourrait rendre disponible à la vue une variable d'instance +@client+ en créant un nouveau +Client+:

<ruby>
def new
  @client = Client.new
end
</ruby>

Le "Layouts & Rendering Guide":layouts_and_rendering.html explique ceci plus en détails.

+ApplicationController+ hérite de +ActionController::Base+, qui décrit beaucoup de méthodes utiles. Ce guide traite de certaines d'entre elles, mais si vous êtes curieux de savoir ce qu'il y a à l'intérieur, vous pouvez toutes les voir dans la documentation de l'API ou dans le code source lui-même.

Seules les méthodes publiques sont appelées en tant qu'actions. C'est une best practice que de diminuer la visibilité des méthodes qui ne sont pas sensées être des  actions, comme les méthodes auxiliaires ou les filtres.

h3. Paramètres

Vous allez surement avoir besoin d'accéder aux données envoyées par les utilisateurs ou aux autres paramètres des actions de votre contrôleur. Il existe deux types de paramètres dans une application web. Le premier, les paramètres qui sont contenus dans l'URL, appelés query string parameters. Les query string comprend tout ce qui se trouve après le "?" dans une URL. Le second type de paramètre est généralement appelé donnée POST. Cette information provient en général d'un formulaire HTML qui a été rempli par l'utilisateur. Ce type est appelé données POST parce qu'il ne peut être envoyé qu'au travers d'une reqète HTTP POST. Rails ne différentie pas les paramètres query string et les paramètres POST, les deux sont disponibles dans le hash +params+ de votre controlleur:

<ruby>
class ClientsController < ActionController::Base
  # Cette action utilise les paramètres query string car elle est exécutée
  # par une requête HTTP GET, mais cela ne change pas la manière
  # dont on accède aux paramètres. L'URL pour cette action
  # pour obtenir la lise des clients activés ressemblerait à:
  # /clients?status=activated
  def index
    if params[:status] == "activated"
      @clients = Client.activated
    else
      @clients = Client.unactivated
    end
  end

  # Cette action utilise les paramètres POST. Ils proviennent la plupart du temps
  # d'un formulaire HTML que l'utilisateur à soumis. L'URL pour cette
  # requète RESTful sera "/clients", et les données seront envoyées
  # dans le corps de la requete.
  def create
    @client = Client.new(params[:client])
    if @client.save
      redirect_to @client
    else
      # Cette ligne remplace le comportement par défaut, qui
      # aurait rendu la vue "create".
      render :action => "new"
    end
  end
end
</ruby>

h4. Hash et tableaux de parametres

Le hash +params+ n'est pas limité à des clés/valeurs uni-dimensionnelles. Il peut contenir des tableaux et des hashs (éventuellement imbriqués). Pour envoyer un tableau de valeurs, ajoutez une paire de crochets "[]" au nom de la clé:

<pre>
GET /clients?ids[]=1&ids[]=2&ids[]=3
</pre>

NOTE: L'URL dans cet exemple sera encodée comme "/clients?ids%5b%5d=1&ids%5b%5d=2&ids%5b%5b=3" car "[" et "]" ne sont pas authorisés dans les URLs. La plupart du temps vous n'aurez pas à vous en occuper car le navigateur s'en chargera, de plus Rails le décodera à la réception. Mais gardez le à l'esprit si jamais vous avez besoin d'envoyer ces requêtes au serveur manuellement.

La valeur de +params[:ids]+ sera +["1", "2", "3"]+. Notez que la valeur des paramètres est toujours composée de chaines de caractères; Rails n'essaie pas de deviner ou de choisir le type.

Pour envoyer un hash, ajoutez le nom de la clé entre les crochets:

<html>
<form action="/clients" method="post">
  <input type="text" name="client[name]" value="Acme" />
  <input type="text" name="client[phone]" value="12345" />
  <input type="text" name="client[address][postcode]" value="12345" />
  <input type="text" name="client[address][city]" value="Carrot City" />
</form>
</html>

Quand ce formulaire est soumis, la valeur de +params[:client]+ sera <tt>{"name" => "Acme", "phone" => "12345", "address" => {"postcode" => "12345", "city" => "Carrot City"}}</tt>. Notez le hash imbriqué dans +params[:client][:address]+.

Remarquez que le hash +params+ est une instance de +HashWithIndifferentAccess+ d'Active Support, qui agit comme un hash qui permet l'utilisation de symboles et chaines interchangeables comme clés.

h4. Parameteres de routage

Le hash +params+ contiens toujours les clés +:controller+ et +:action+, mais il est préférables d'utiliser les méthodes +controller_name+ et +action_name+ pour accéder ces valeurs. Tous les autres paramètres définis par le routage, comme +:id+ seront aussi disponibles. Par exemple, considérons une liste de clients qui puisse montrer le statut actif ou inactif des clients. On peut ajouter une route qui capture le paramètre +:status+ dans une "pretty" URL:

<ruby>
map.connect "/clients/:status", 
  :controller => "clients",
  :action => "index",
  :foo => "bar"
</ruby>

Dans ce cas, quand un utilisateur accède à l'URL +/clients/active+, +params[:status]+ sera fixé à "active". Quand cette route est utilisée, +params[:foo]+ sera aussi fixé à "bar" comme s'il avait été passé dans une query string. De la même manière +params[:action]+ contiendra "index".

h4. +default_url_options+

Vous pouvez fixer des paramètres par défaut globaux qui seront utilisés lors de la génération d'URLs avec +default_url_options+. Pour ce faire, définissez une méthode avec ce nom dans votre contrôleur:

<ruby>
class ApplicationController < ActionController::Base
  # The paramètre options est le hash passé dans 'url_for'
  def default_url_options(options)
    {:locale => I18n.locale}
  end
end
</ruby>

Ces options seront utilisées comme point de départ lors de la génération d'URLs, il est donc possible qu'elles soient remplacées par +url_for+. Comme cette méthode est définie dans le contrôleur, vous pouvez la définir dans +ApplicationController+ pour qu'elle soit utilisée dans toutes les générations d'URL, ou vous pouvez la définir dans un seul contrôleur pour les URLs qui seront générées uniquement via celui-ci.


h3. Les Sessions

Votre application a une session pour chaque utilisateur dans laquelle vous pouvez stocker des données qui persisteront entres les requetes. La session est uniquement disponible dans le contrôleur et la vue et peut utiliser un de ces différents mécanismes de stockage:

* CookieStore - Stocke tout sur le client.
* DRbStore - Stocke les données sur un serveur DRb.
* MemCacheStore - Stocke les données dans un memcache.
* ActiveRecordStore - Stocke les données dans une base de données en utilisant Active Record.

Tous les entrepôts de session utilisent un cookie pour stocker un ID unique à chaque session (vous devez utiliser un cookie, Rails ne vous permettra pas de passer l'ID d'une session dans une URL car ce n'est pas sûr).

Pour la plupart des entrpots cette ID est utilisée pour trouver les données de la sessionsur le serveur, par exemple dans une table d'une base de données. Il y a une exception, et c'est l'entrepot recommandé et par défaut - le CookieStore - qui stocke toutes les données d'une session dans le cookie lui-même (l'ID est toujours disponible si vous en avez besoin). Ca a l'avantage d'être trés leger et n'a pas besoin d'être mis en place dans une nouvelle application pour utiliser la session. Les données du cookie sont signées cryptographiquement pour les rendre infalsifiables, mais elles ne sont pas cryptées, donc quiconque y a accès peut lire leur contenu mais pas l'éditer (Rails ne les acceptera pas s'ils ont été édités).

Le CookieStore peut stocker environ 4kB de données -- beaucoup moins que les autres -- mais c'est généralement suffisant. Stocker de grandes quantités de données dans la session n'est pas encouragé quel que soit l'entrepôt de session que votre application utilise. Vous devez surtout éviter de stocker des objets complexes (tout ce qui n'est pas un objet Ruby basique comme les instances de modèle) dans une  session, car le serveur ne sera peut-être pas en mesure de les rassembler entre les requêtes, ce qui produira une erreur.

Vous trouverez plus d'informations sur le stockage des sessions dans le "Security Guide":security.html.

Si vous avez besoin d'un mécanisme de stockage des sessions différent, vous pouvez le changer dans le fichier +config/initializers/session_store.rb+:

<ruby>
# Use the database for sessions instead of the cookie-based default,
# which shouldn't be used to store highly confidential information
# (create the session table with "rake db:sessions:create")
# ActionController::Base.session_store = :active_record_store
</ruby>

Rails met en place une clé de session (le nom du cookie) et (pour le CookieStore) une clé secrète utilisée lors de la signature des données de la session. Elles peuvent aussi être changées dans +config/initializers/session_store.rb+:

<ruby>
# Your secret key for verifying cookie session data integrity.
# If you change this key, all old sessions will become invalid!
# Make sure the secret is at least 30 characters and all random, 
# no regular words or you'll be exposed to dictionary attacks.
ActionController::Base.session = {
  :key         => '_yourappname_session',
  :secret      => '4f50711b8f0f49572...'
}
</ruby>

NOTE: La modification de la clé secret avec l'utilisation de CookieStore invalidera toutes les sessions existantes.

h4. Accéder à la Session

Dans votre contrôleur vous pouvez accéder à la session à travers la méthode d'instance +session+.

NOTE: Les sessions sont chargées paresseusement. Si vous n'y accédez pas dans le code de vos actions, elles ne seront pas chargées. Ainsi vous n'aurez jamais à désactiver les sessions, le fait de ne pas y accéder fera l'affaire.

Les valeurs d'une session sont stockées dans des paires clé/valeur comme dans un hash:

<ruby>
class ApplicationController < ActionController::Base

  private

  # Trouve l'utilisateur avec l'ID stocké dans la session avec la clé
  # :current_user_id. C'est une manière habituelle de gérer l'authentification
  # d'un utilisateur dans une application Rails; l'authentification fixe la valeur
  # de la session et la déconnection l'enlève.
  def current_user
    @_current_user ||= session[:current_user_id] &&
      User.find(session[:current_user_id])
  end
end
</ruby>

Pour stocker une information dans la session, assignez la à la clé comme un hash:

<ruby>
class LoginsController < ApplicationController
  # "Create" un login, aka "log the user in"
  def create
    if user = User.authenticate(params[:username], params[:password])
      # Sauve l'ID de l'utilisateur dans la session pour une réutilisation
      # dans les requetes suivantes.
      session[:current_user_id] = user.id
      redirect_to root_url
    end
  end
end
</ruby>

Pour supprimer une information de la session, assignez la clé à +nil+:

<ruby>
class LoginsController < ApplicationController
  # "Delete" a login, aka "log the user out"
  def destroy
    # Supprime user id de la session
    session[:current_user_id] = nil
    redirect_to root_url
  end
end
</ruby>

Pour réinitialiser toute la session, utilisez +reset_session+.

h4. Le Flash

Le flash est une partie spéciale de la session qui est nettoyé à chaque requête. Ce qui implique que les valeurs stockées ne seront disponibles que pour la requête suivante ce qui est utile pour les messages d'erreur etc. Il sont accessibles de la même manière que la session, comme un hash. Utilisons l'action d'une déconnection comme exemple. Le contrôleur peut envoyer message qui sera affiché à l'utilisateur lors de la requête suivante:

<ruby>
class LoginsController < ApplicationController
  def destroy
    session[:current_user_id] = nil
    flash[:notice] = "Vous avez été déconnecté"
    redirect_to root_url
  end
end
</ruby>

The +destroy+ action redirects to the application's +root_url+, where the message will be displayed. Note that it's entirely up to the next action to decide what, if anything, it will do with what the previous action put in the flash. It's conventional to display eventual errors or notices from the flash in the application's layout:

<ruby>
<html>
  <!-- <head/> -->
  <body>
    <% if flash[:notice] -%>
      <p class="notice"><%= flash[:notice] %></p>
    <% end -%>
    <% if flash[:error] -%>
      <p class="error"><%= flash[:error] %></p>
    <% end -%>
    <!-- more content -->
  </body>
</html>
</ruby>

This way, if an action sets an error or a notice message, the layout will display it automatically.

If you want a flash value to be carried over to another request, use the +keep+ method:

<ruby>
class MainController < ApplicationController
  # Let's say this action corresponds to root_url, but you want
  # all requests here to be redirected to UsersController#index.
  # If an action sets the flash and redirects here, the values
  # would normally be lost when another redirect happens, but you
  # can use 'keep' to make it persist for another request.
  def index
    # Will persist all flash values.
    flash.keep

    # You can also use a key to keep only some kind of value. 
    # flash.keep(:notice)
    redirect_to users_url
  end
end
</ruby>

h5. +flash.now+

By default, adding values to the flash will make them available to the next request, but sometimes you may want to access those values in the same request. For example, if the +create+ action fails to save a resource and you render the +new+ template directly, that's not going to result in a new request, but you may still want to display a message using the flash. To do this, you can use +flash.now+ in the same way you use the normal +flash+:

<ruby>
class ClientsController < ApplicationController
  def create
    @client = Client.new(params[:client])
    if @client.save
      # ...
    else
      flash.now[:error] = "Could not save client"
      render :action => "new"
    end
  end
end
</ruby>

h3. Cookies

Your application can store small amounts of data on the client -- called cookies -- that will be persisted across requests and even sessions. Rails provides easy access to cookies via the +cookies+ method, which -- much like the +session+ -- works like a hash:

<ruby>
class CommentsController < ApplicationController
  def new
    # Auto-fill the commenter's name if it has been stored in a cookie
    @comment = Comment.new(:name => cookies[:commenter_name])
  end

  def create
    @comment = Comment.new(params[:comment])
    if @comment.save
      flash[:notice] = "Thanks for your comment!"
      if params[:remember_name]
        # Remember the commenter's name.
        cookies[:commenter_name] = @comment.name
      else
        # Delete cookie for the commenter's name cookie, if any.
        cookies.delete(:commenter_name)
      end
      redirect_to @comment.article
    else
      render :action => "new"
    end
  end
end
</ruby>

Note that while for session values you set the key to +nil+, to delete a cookie value you should use +cookies.delete(:key)+.

h3. Filters

Filters are methods that are run before, after or "around" a controller action. 

Filters are inherited, so if you set a filter on +ApplicationController+, it will be run on every controller in your application. 

Before filters may halt the request cycle. A common before filter is one which requires that a user is logged in for an action to be run. You can define the filter method this way:

<ruby>
class ApplicationController < ActionController::Base
  before_filter :require_login

  private

  def require_login
    unless logged_in?
      flash[:error] = "You must be logged in to access this section"
      redirect_to new_login_url # halts request cycle
    end
  end

  # The logged_in? method simply returns true if the user is logged
  # in and false otherwise. It does this by "booleanizing" the
  # current_user method we created previously using a double ! operator.
  # Note that this is not common in Ruby and is discouraged unless you
  # really mean to convert something into true or false.
  def logged_in?
    !!current_user
  end
end
</ruby>

The method simply stores an error message in the flash and redirects to the login form if the user is not logged in. If a before filter renders or redirects, the action will not run. If there are additional filters scheduled to run after that filter they are also cancelled.

In this example the filter is added to +ApplicationController+ and thus all controllers in the application inherit it. This will make everything in the application require the user to be logged in in order to use it. For obvious reasons (the user wouldn't be able to log in in the first place!), not all controllers or actions should require this. You can prevent this filter from running before particular actions with +skip_before_filter+:

<ruby>
class LoginsController < ApplicationController
  skip_before_filter :require_login, :only => [:new, :create]
end
</ruby>

Now, the +LoginsController+'s +new+ and +create+ actions will work as before without requiring the user to be logged in. The +:only+ option is used to only skip this filter for these actions, and there is also an +:except+ option which works the other way. These options can be used when adding filters too, so you can add a filter which only runs for selected actions in the first place.

h4. After Filters and Around Filters

In addition to before filters, you can run filters after an action has run or both before and after. The after filter is similar to the before filter, but because the action has already been run it has access to the response data that's about to be sent to the client. Obviously, after filters can not stop the action from running.

Around filters are responsible for running the action, but they can choose not to, which is the around filter's way of stopping it.

<ruby>
# Example taken from the Rails API filter documentation:
# http://api.rubyonrails.org/classes/ActionController/Filters/ClassMethods.html
class ApplicationController < ActionController::Base
  around_filter :catch_exceptions

  private

  def catch_exceptions
    yield
  rescue => exception
    logger.debug "Caught exception! #{exception}"
    raise
  end
end
</ruby>

h4. Other Ways to Use Filters

While the most common way to use filters is by creating private methods and using *_filter to add them, there are two other ways to do the same thing.

The first is to use a block directly with the *_filter methods. The block receives the controller as an argument, and the +require_login+ filter from above could be rewritten to use a block:

<ruby>
class ApplicationController < ActionController::Base
  before_filter do |controller|
    redirect_to new_login_url unless controller.send(:logged_in?)
  end
end
</ruby>

Note that the filter in this case uses +send+ because the +logged_in?+ method is private and the filter is not run in the scope of the controller. This is not the recommended way to implement this particular filter, but in more simple cases it might be useful.

The second way is to use a class (actually, any object that responds to the right methods will do) to handle the filtering. This is useful in cases that are more complex and can not be implemented in a readable and reusable way using the two other methods. As an example, you could rewrite the login filter again to use a class:

<ruby>
class ApplicationController < ActionController::Base
  before_filter LoginFilter
end

class LoginFilter
  def self.filter(controller)
    unless controller.send(:logged_in?)
      controller.flash[:error] = "You must be logged in"
      controller.redirect_to controller.new_login_url
    end
  end
end
</ruby>

Again, this is not an ideal example for this filter, because it's not run in the scope of the controller but gets the controller passed as an argument. The filter class has a class method +filter+ which gets run before or after the action, depending on if it's a before or after filter. Classes used as around filters can also use the same +filter+ method, which will get run in the same way. The method must +yield+ to execute the action. Alternatively, it can have both a +before+ and an +after+ method that are run before and after the action.

The Rails API documentation has "more information on using filters":http://api.rubyonrails.org/classes/ActionController/Filters/ClassMethods.html.

h3. Verification

Verifications make sure certain criteria are met in order for a controller or action to run. They can specify that a certain key (or several keys in the form of an array) is present in the +params+, +session+ or +flash+ hashes or that a certain HTTP method was used or that the request was made using +XMLHttpRequest+ (Ajax). The default action taken when these criteria are not met is to render a 400 Bad Request response, but you can customize this by specifying a redirect URL or rendering something else and you can also add flash messages and HTTP headers to the response. It is described in the "API documentation":http://api.rubyonrails.org/classes/ActionController/Verification/ClassMethods.html as "essentially a special kind of before_filter".

Here's an example of using verification to make sure the user supplies a username and a password in order to log in:

<ruby>
class LoginsController < ApplicationController
  verify :params => [:username, :password],
         :render => {:action => "new"},
         :add_flash => {
           :error => "Username and password required to log in"
         }

  def create
    @user = User.authenticate(params[:username], params[:password])
    if @user
      flash[:notice] = "You're logged in"
      redirect_to root_url
    else
      render :action => "new"
    end
  end
end
</ruby>

Now the +create+ action won't run unless the "username" and "password" parameters are present, and if they're not, an error message will be added to the flash and the +new+ action will be rendered. But there's something rather important missing from the verification above: It will be used for *every* action in LoginsController, which is not what we want. You can limit which actions it will be used for with the +:only+ and +:except+ options just like a filter:

<ruby>
class LoginsController < ApplicationController
  verify :params => [:username, :password],
         :render => {:action => "new"},
         :add_flash => {
           :error => "Username and password required to log in"
         },
         :only => :create # Run only for the "create" action
end
</ruby>

h3. Request Forgery Protection

Cross-site request forgery is a type of attack in which a site tricks a user into making requests on another site, possibly adding, modifying or deleting data on that site without the user's knowledge or permission.

The first step to avoid this is to make sure all "destructive" actions (create, update and destroy) can only be accessed with non-GET requests. If you're following RESTful conventions you're already doing this. However, a malicious site can still send a non-GET request to your site quite easily, and that's where the request forgery protection comes in. As the name says, it protects from forged requests.

The way this is done is to add a non-guessable token which is only known to your server to each request. This way, if a request comes in without the proper token, it will be denied access.

If you generate a form like this:

<ruby>
<% form_for @user do |f| -%>
  <%= f.text_field :username %>
  <%= f.text_field :password -%>
<% end -%>
</ruby>

You will see how the token gets added as a hidden field:

<html>
<form action="/users/1" method="post">
<input type="hidden" 
       value="67250ab105eb5ad10851c00a5621854a23af5489"
       name="authenticity_token"/>
<!-- fields -->
</form>
</html>

Rails adds this token to every form that's generated using the "form helpers":form_helpers.html, so most of the time you don't have to worry about it. If you're writing a form manually or need to add the token for another reason, it's available through the method +form_authenticity_token+:

The +form_authenticity_token+ generates a valid authentication token. That's useful in places where Rails does not add it automatically, like in custom Ajax calls.

The "Security Guide":security.html has more about this and a lot of other security-related issues that you should be aware of when developing a web application.

h3. The Request and Response Objects

In every controller there are two accessor methods pointing to the request and the response objects associated with the request cycle that is currently in execution. The +request+ method contains an instance of +AbstractRequest+ and the +response+ method returns a response object representing what is going to be sent back to the client.

h4. The +request+ Object

The request object contains a lot of useful information about the request coming in from the client. To get a full list of the available methods, refer to the "API documentation":http://api.rubyonrails.org/classes/ActionController/AbstractRequest.html. Among the properties that you can access on this object are:

|_.Property of +request+|_.Purpose|
|host|The hostname used for this request.|
|domain(n=2)|The hostname's first +n+ segments, starting from the right (the TLD).|
|format|The content type requested by the client.|
|method|The HTTP method used for the request.|
|get?, post?, put?, delete?, head?|Returns true if the HTTP method is GET/POST/PUT/DELETE/HEAD.|
|headers|Returns a hash containing the headers associated with the request.|
|port|The port number (integer) used for the request.|
|protocol|Returns a string containing the protocol used plus "://", for example "http://".|
|query_string|The query string part of the URL, i.e., everything after "?".|
|remote_ip|The IP address of the client.|
|url|The entire URL used for the request.|

h5. +path_parameters+, +query_parameters+, and +request_parameters+

Rails collects all of the parameters sent along with the request in the +params+ hash, whether they are sent as part of the query string or the post body. The request object has three accessors that give you access to these parameters depending on where they came from. The +query_parameters+ hash contains parameters that were sent as part of the query string while the +request_parameters+ hash contains parameters sent as part of the post body. The +path_parameters+ hash contains parameters that were recognized by the routing as being part of the path leading to this particular controller and action.

h4. The +response+ Object

The response object is not usually used directly, but is built up during the execution of the action and rendering of the data that is being sent back to the user, but sometimes - like in an after filter - it can be useful to access the response directly. Some of these accessor methods also have setters, allowing you to change their values.

|_.Property of +response+|_.Purpose|
|body|This is the string of data being sent back to the client. This is most often HTML.|
|status|The HTTP status code for the response, like 200 for a successful request or 404 for file not found.|
|location|The URL the client is being redirected to, if any.|
|content_type|The content type of the response.|
|charset|The character set being used for the response. Default is "utf-8".|
|headers|Headers used for the response.|

h5. Setting Custom Headers

If you want to set custom headers for a response then +response.headers+ is the place to do it. The headers attribute is a hash which maps header names to their values, and Rails will set some of them automatically. If you want to add or change a header, just assign it to +response.headers+ this way:

<ruby>
response.headers["Content-Type"] = "application/pdf"
</ruby>

h3. HTTP Authentications

Rails comes with two built-in HTTP authentication mechanisms:

* Basic Authentication
* Digest Authentication

h4. HTTP Basic Authentication

HTTP basic authentication is an authentication scheme that is supported by the majority of browsers and other HTTP clients. As an example, consider an administration section which will only be available by entering a username and a password into the browser's HTTP basic dialog window. Using the built-in authentication is quite easy and only requires you to use one method, +authenticate_or_request_with_http_basic+.

<ruby>
class AdminController < ApplicationController
  USERNAME, PASSWORD = "humbaba", "5baa61e4"

  before_filter :authenticate

  private

  def authenticate
    authenticate_or_request_with_http_basic do |username, password|
      username == USERNAME &&
      Digest::SHA1.hexdigest(password) == PASSWORD
    end
  end
end
</ruby>

With this in place, you can create namespaced controllers that inherit from +AdminController+. The before filter will thus be run for all actions in those controllers, protecting them with HTTP basic authentication.

h4. HTTP Digest Authentication

HTTP digest authentication is superior to the basic authentication as it does not require the client to send an unencrypted password over the network (though HTTP basic authentication is safe over HTTPS). Using digest authentication with Rails is quite easy and only requires using one method, +authenticate_or_request_with_http_digest+.

<ruby>
class AdminController < ApplicationController
  USERS = { "lifo" => "world" }

  before_filter :authenticate

  private

  def authenticate
    authenticate_or_request_with_http_digest do |username|
      USERS[username]
    end
  end
end
</ruby>

As seen in the example above, the +authenticate_or_request_with_http_digest+ block takes only one argument - the username. And the block returns the password. Returning +false+ or +nil+ from the +authenticate_or_request_with_http_digest+ will cause authentication failure.

h3. Streaming and File Downloads

Sometimes you may want to send a file to the user instead of rendering an HTML page. All controllers in Rails have the +send_data+ and the +send_file+ methods, which will both stream data to the client. +send_file+ is a convenience method that lets you provide the name of a file on the disk and it will stream the contents of that file for you.

To stream data to the client, use +send_data+:

<ruby>
require "prawn"
class ClientsController < ApplicationController
  # Generates a PDF document with information on the client and
  # returns it. The user will get the PDF as a file download.
  def download_pdf
    client = Client.find(params[:id])
    send_data(generate_pdf, 
              :filename => "#{client.name}.pdf",
              :type => "application/pdf")
  end

  private

  def generate_pdf(client)
    Prawn::Document.new do
      text client.name, :align => :center
      text "Address: #{client.address}"
      text "Email: #{client.email}"
    end.render
  end
end
</ruby>

The +download_pdf+ action in the example above will call a private method which actually generates the PDF document and returns it as a string. This string will then be streamed to the client as a file download and a filename will be suggested to the user. Sometimes when streaming files to the user, you may not want them to download the file. Take images, for example, which can be embedded into HTML pages. To tell the browser a file is not meant to be downloaded, you can set the +:disposition+ option to "inline". The opposite and default value for this option is "attachment".

h4. Sending Files

If you want to send a file that already exists on disk, use the +send_file+ method.

<ruby>
class ClientsController < ApplicationController
  # Stream a file that has already been generated and stored on disk.
  def download_pdf
    client = Client.find(params[:id])
    send_data("#{RAILS_ROOT}/files/clients/#{client.id}.pdf",
              :filename => "#{client.name}.pdf",
              :type => "application/pdf")
  end
end
</ruby>

This will read and stream the file 4kB at the time, avoiding loading the entire file into memory at once. You can turn off streaming with the +:stream+ option or adjust the block size with the +:buffer_size+ option.

WARNING: Be careful when using data coming from the client (params, cookies, etc.) to locate the file on disk, as this is a security risk that might allow someone to gain access to files they are not meant to see.

TIP: It is not recommended that you stream static files through Rails if you can instead keep them in a public folder on your web server. It is much more efficient to let the user download the file directly using Apache or another web server, keeping the request from unnecessarily going through the whole Rails stack. Although if you do need the request to go through Rails for some reason, you can set the +:x_sendfile+ option to true, and Rails will let the web server handle sending the file to the user, freeing up the Rails process to do other things. Note that your web server needs to support the +X-Sendfile+ header for this to work.

h4. RESTful Downloads

While +send_data+ works just fine, if you are creating a RESTful application having separate actions for file downloads is usually not necessary. In REST terminology, the PDF file from the example above can be considered just another representation of the client resource. Rails provides an easy and quite sleek way of doing "RESTful downloads". Here's how you can rewrite the example so that the PDF download is a part of the +show+ action, without any streaming:

<ruby>
class ClientsController < ApplicationController
  # The user can request to receive this resource as HTML or PDF.
  def show
    @client = Client.find(params[:id])

    respond_to do |format|
      format.html
      format.pdf { render :pdf => generate_pdf(@client) }
    end
  end
end
</ruby>

In order for this example to work, you have to add the PDF MIME type to Rails. This can be done by adding the following line to the file +config/initializers/mime_types.rb+:

<ruby>
Mime::Type.register "application/pdf", :pdf
</ruby>

NOTE: Configuration files are not reloaded on each request, so you have to restart the server in order for their changes to take effect.

Now the user can request to get a PDF version of a client just by adding ".pdf" to the URL:

<shell>
GET /clients/1.pdf
</shell>

h3. Parameter Filtering

Rails keeps a log file for each environment in the +log+ folder. These are extremely useful when debugging what's actually going on in your application, but in a live application you may not want every bit of information to be stored in the log file. The +filter_parameter_logging+ method can be used to filter out sensitive information from the log. It works by replacing certain values in the +params+ hash with "[FILTERED]" as they are written to the log. As an example, let's see how to filter all parameters with keys that include "password":

<ruby>
class ApplicationController < ActionController::Base
  filter_parameter_logging :password
end
</ruby>

The method works recursively through all levels of the +params+ hash and takes an optional second parameter which is used as the replacement string if present. It can also take a block which receives each key in turn and replaces those for which the block returns true.

h3. Rescue

Most likely your application is going to contain bugs or otherwise throw an exception that needs to be handled. For example, if the user follows a link to a resource that no longer exists in the database, Active Record will throw the +ActiveRecord::RecordNotFound+ exception.

Rails' default exception handling displays a "500 Server Error" message for all exceptions. If the request was made locally, a nice traceback and some added information gets displayed so you can figure out what went wrong and deal with it. If the request was remote Rails will just display a simple "500 Server Error" message to the user, or a "404 Not Found" if there was a routing error or a record could not be found. Sometimes you might want to customize how these errors are caught and how they're displayed to the user. There are several levels of exception handling available in a Rails application:

h4. The Default 500 and 404 Templates

By default a production application will render either a 404 or a 500 error message. These messages are contained in static HTML files in the +public+ folder, in +404.html+ and +500.html+ respectively. You can customize these files to add some extra information and layout, but remember that they are static; i.e. you can't use RHTML or layouts in them, just plain HTML.

h4. +rescue_from+

If you want to do something a bit more elaborate when catching errors, you can use +rescue_from+, which handles exceptions of a certain type (or multiple types) in an entire controller and its subclasses.

When an exception occurs which is caught by a +rescue_from+ directive, the exception object is passed to the handler. The handler can be a method or a +Proc+ object passed to the +:with+ option. You can also use a block directly instead of an explicit +Proc+ object.

Here's how you can use +rescue_from+ to intercept all +ActiveRecord::RecordNotFound+ errors and do something with them.

<ruby>
class ApplicationController < ActionController::Base
  rescue_from ActiveRecord::RecordNotFound, :with => :record_not_found

  private

  def record_not_found
    render :text => "404 Not Found", :status => 404
  end
end
</ruby>

Of course, this example is anything but elaborate and doesn't improve on the default exception handling at all, but once you can catch all those exceptions you're free to do whatever you want with them. For example, you could create custom exception classes that will be thrown when a user doesn't have access to a certain section of your application:

<ruby>
class ApplicationController < ActionController::Base
  rescue_from User::NotAuthorized, :with => :user_not_authorized

  private

  def user_not_authorized
    flash[:error] = "You don't have access to this section."
    redirect_to :back
  end
end

class ClientsController < ApplicationController
  # Check that the user has the right authorization to access clients.
  before_filter :check_authorization

  # Note how the actions don't have to worry about all the auth stuff.
  def edit
    @client = Client.find(params[:id])
  end

  private

  # If the user is not authorized, just throw the exception.
  def check_authorization
    raise User::NotAuthorized unless current_user.admin?
  end
end
</ruby>

NOTE: Certain exceptions are only rescuable from the +ApplicationController+ class, as they are raised before the controller gets initialized and the action gets executed. See Pratik Naik's "article":http://m.onkey.org/2008/7/20/rescue-from-dispatching on the subject for more information.

h3. Changelog

"Lighthouse Ticket":http://rails.lighthouseapp.com/projects/16213-rails-guides/tickets/17

* February 17, 2009: Yet another proofread by Xavier Noria.

* November 4, 2008: First release version by Tore Darell
